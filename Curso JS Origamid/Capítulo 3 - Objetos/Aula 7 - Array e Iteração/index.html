<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array</title>
</head>
<style>
        body {
            background-color: #303030;
            color: #f0f0f0;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 , h3{
            color: #fff3c6;
            font-family: Arial, sans-serif;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        p {
            color: #fffbeb;
            font-family: monospace;
        }
        .linha {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        code {
            background: #505050;
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            flex: 1;
            padding-top: 30px;
            padding-bottom: 30px;
        }
        .saida {
            background: #404040;
            color: #ffcc00;
            padding: 10px;
            border-radius: 5px;
            font-style: monospace;
            flex: 1;
            text-align: right;
            padding-top: 30px;
            padding-bottom: 30px;
        }
        li{
            color: #ffeda5;
            list-style-type:disc ;
        }
        li::marker{
            color: #ffcc00;
        }
    </style>
</head>
<body>
    <h1>Aulas de JavaScript</h1>
    <h2>Aula 7 - Array e Iteração</h2>
    <div class="container">
        <h3>Iteração com Array's</h3>
        <p>Array's costumam sempre ter interações em grupos, seja, em sequência</p>
        <h2>[].forEach(callback(itemAtual, index, array))</h2>
        <p>Função de callback é executada para cada item da array. Ela possui três argumentos, itemAtual (valor do item da array), index (index do valor na array) e array (array original)</p>
        <div class="linha">
            <code>
<pre>const carros = ['Ford','Fiat','Honda'];
carros.forEach(function(item, index, array){
    console.log(item.tuUpperCase());    
});</pre>
            </code>

            <p class="saida">
                FORD <br>
                FIAT <br>
                HONDA
            </p>
        </div>
        <p>Com Arrow Function</p>
        <div class="linha">
            <code>
<pre>carros.forEach((item, index, array) => {
    console.log(item.toUpperCase());
})</pre>
            </code>
            <p class="saida">FORD <br>
                FIAT <br>
                HONDA
            </p>
        </div>
        <h3>Arrow Function</h3>
        <ul>
            <li>Teste1</li>
            <li>Teste2</li>
            <li>Teste3</li>
        </ul>
        <div class="linha">
            <code>
<pre>const li = document.querySelectorAll('li');

li.forEach(i => i.classList.add('ativa'));

</pre>
            </code>
            <p class="saida">Adiciona uma classe chamada 'ativa' a cada li do HTML</p>
        </div>

        <br>

        <div class="linha">
            <code>
<pre>const li = document.querySelectorAll('li');

li.forEach(function(item){
    item.classList.add('ativa');
});</pre>
            </code>
            <p class="saida">Funciona exatamente igual à outra linha anterior <br>
        Adiciona uma classe chamada 'ativa' a cada li do HTML <br>
        Caso acrescente algum outro argumento como um index, o mesmo pode ser adicionado em casa classe no elemento.</p>
        </div>
        <h3>Modificar a Array Original</h3>
        <p>Você pode modificar os valores da array dentro da iteração usando o índice</p>

        <div class="linha">
            <code>
<pre>const carros2 = ['Ford', 'Fiat', 'Honda']
carros2.forEach((item, index, array) => {
    array[index] = item.toUpperCase();
});
console.log(carros2);</pre>
            </code>
            <p class="saida">['FORD', 'FIAT', 'HONDA']</p>
        </div>

        <h3>Arrow Function</h3>
        <p>Adicionar classes aos elementos</p>
        <div class="linha">
            <code>
<pre>const li = document.querySelectorAll('li');

li.forEach((i,index) => i.classList.add('ativa' + index));

li.forEach(function(item, index){
    item.classList.add('ativa' + index);
});</pre>
            </code>
            <p class="saida">Adiciona classe ativa0, ativa1, ativa2...</p>
        </div>

        <h3>Concatenar strings</h3>
        <p>Adicionar texto aos valores existentes na array</p>

        <div class="linha">
            <code>
<pre>const carros3 = ['Ford', 'Fiat', 'Honda'];
carros3.forEach((item, index, array) => {
    array[index] = 'Carro ' + item;
});
console.log(carros3);</pre>
            </code>
            <p class="saida">['Carro Ford', 'Carro Fiat', 'Carro Honda']</p>
        </div>

        <h2>[].map(callback(itemAtual, index, array))</h2>
        <p>Funciona da mesma forma que o forEach(), porém ao invés de retornar undefined, retorna uma nova array com valores atualizados de acordo com o return de cada iteração</p>
        <div class="linha">
            <code>
<pre>const carros4 = ['Ford', 'Fiat', 'Honda'];

const newCarros = carros4.map((item) => {
    return 'Carro '+ item;
});

console.log(carros4, newCarros);</pre>
            </code>
            <p class="saida">['Ford', 'Fiat', 'Honda'] <br> ['Carro Ford', 'Carro Fiat', 'Carro Honda']</p>
        </div>

        <h3>Transformar para UPPERCASE</h3>
        <p>Converter todos os valores da array para letras maiúsculas</p>

        <div class="linha">
            <code>
<pre>const novaArray = carros4.map((item, index, array) => {
    return item.toUpperCase();
});

console.log(novaArray, carros4);</pre>
            </code>
            <p class="saida">['FORD', 'FIAT', 'HONDA'] <br> ['Ford', 'Fiat', 'Honda']</p>
        </div>

        <h3>Multiplicar números</h3>
        <p>Usar map para fazer operações matemáticas com os valores da array</p>
        
        <div class="linha">
            <code>
<pre>const numeros = [2, 4, 5, 6, 78];

const numerosX2 = numeros.map(n => n * 2);

console.log(numerosX2);</pre>
            </code>
            <p class="saida">[4, 8, 10, 12, 156]</p>
        </div>

        <h3>Valor Retornado</h3>
        <p>Se não retornarmos nenhum valor durante a iteração utilizando map, o valor retornado como de qualquer função que não possui o return, será undefined.</p>
        <div class="linha">
            <code>
<pre>const carros5 = ['Ford', 'Fiat', 'Honda'];
const newCarros2 = carros.map((item) => {
    const novoValor = 'Carro ' + item;
});

console.log(newCarros2);</pre>
            </code>
            <p class="saida">[undefined, undefined, undefined]</p>
        </div>

        <h3>Arrow Function e [].map()</h3>
        <p>Uma Arrow Function de linha única e sem chaves irá retornar o valor após a fat arrow =></p>
        <div class="linha">
            <code>
<pre>const numeros2 = [2, 4, 5, 6, 8, 10, 12, 14];

const numerosX3 = numeros2.map(n => n * 3);

console.log(numerosX3);</pre>
            </code>
            <p class="saida">[6, 12, 15, 18, 24, 30, 36, 42]</p>
        </div>

        <h3>[].map() vs [].forEach()</h3>
        <p>Se o objetivo for modificar os valores da array atual, sempre utilize o map, pois assim uma nova array com os valores modificados é retornada e você pode imediatamente iterar novamente sobre estes valores.</p>
        <p> [].forEach() altera a array e pode adicionar valores e classes à array existente.</p>
        <p> [].map() já faz um pouco diferente, este cria uma nova array.</p>
        <div class="linha">
            <code>
<pre>const numeros4 = [2, 4, 5, 6, 8, 10, 12, 14];

const numerosX4 = numeros4.map(n => n * 4);

console.log(numerosX4);</pre>
            </code>
            <p class="saida">[8, 16, 20, 24, 32, 40, 48, 56]</p>
        </div>
        <h3>Exemplo de uso de [].map()</h3>
        <p>Criando uma nova array com alguns dos dados de outra array anterior.</p>
        <div class="linha">
            <code>
<pre>const aulas = [
    {
        nome:'HTML 1',
        min: 15 
    },
    {
        nome:'HTML 2',
        min: 10 
    },
    {
        nome:'CSS 1',
        min: 20 
    },
    {
        nome:'JS 1',
        min: 25 
    },
]

const tempoAulas = aulas.map(aula=> aula.min);
function nomeAulas(aula) {
    return aula.nome;
}
const arrayNomeAulas = aulas.map(nomeAulas);

console.log(tempoAulas,arrayNomeAulas);</pre>
            </code>
            <p class="saida">[15, 10, 20, 25] <br> ['HTML 1', 'HTML 2', 'CSS 1', 'JS 1']</p>
        </div>

        <h2>[].reduce()</h2>
        <p>[].reduce(callback(acumulador, valorAtual, index, array), valorInicial)</p>
        <p>Executa a função de callback para cada item da Array. Um valor especial existe nessa função de callback, ele é chamado de acumulador, mas é na verdade apenas o retorno da iteração anterior.</p>
        <div class="linha">
            <code>
<pre>const aulas2 = [10, 25, 30];
const total1 = aulas2.reduce((acumulador, atual, index, array) => {
    console.log(acumulador, atual, index, array);
    return acumulador + atual;
});

console.log(total1);</pre>
            </code>
            <p class="saida">undefined 10 0 (3) [10, 25, 30] <br> undefined 25 1 (3) [10, 25, 30] <br> undefined 30 2 (3) [10, 25, 30] <br> 65</p>
        </div>

        <h3>Valor inicial no reduce</h3>
        <p>No caso anterior, não teve valor inicial definido. Agora com um valor inicial de 100:</p>
        <div class="linha">
            <code>
<pre>const total2 = aulas2.reduce((acc, cur) => acc + cur, 100);

console.log(total2);</pre>
            </code>
            <p class="saida">165</p>
        </div>
    </div>
    <script src="script.js"></script>
</body>
</html>